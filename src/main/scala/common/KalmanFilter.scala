package common

import breeze.linalg._
import org.apache.commons.math3.random.MersenneTwister
import breeze.stats.distributions._

/**
  * Basic class of Kalman Filter model.
  * Below is the Kalman Filter model that we consider in this application.
  *
  * x_{t+1} = Ax_t + Bu_t + w_t
  * z_t = Hx_t + v_t
  *
  * where x_t, u_t, z_t are each hidden, control, observed variable and w_t, v_t are stochastic variable that follows w_t ~ N(0, Q), v_t ~ N(0, R)
  * A, B, H, Q, and R are matrix parameter R are matrix parameters.
  * This class includes each parameters for the model; A, B, H, Q, R
  * This class also can generate new sequences of pairs of hidden and control variables that follow the model.
  *
  * Created by tara on 2016/12/17.
  */
case class KalmanFilter(A: Matrices, B: Option[Matrices], H: Matrices, Q: Matrices, R: Matrices) {

  //dimension of hidden variables
  val n = A.cols
  //dimension of observed variables
  val m = H.rows
  //dimension of control variables
  val l = B match {
    case Some(c) => c.cols;
    case None => 0
  }
  //code number used for calculating seed
  val code = System.identityHashCode(this)

  override def toString: String = {
    val s = new StringBuilder()
    s.append(n + "\n" + m + "\n" + l + "\n")
    s.append("\n" + A.toString)
    B match {
      case Some(b) => s.append("\n" + b.toString);
      case None => s.append("\n")
    }
    s.append("\n" + H.toString)
    s.append("\n" + Q.toString)
    s.append("\n" + R.toString)
    s.toString
  }

  /**
    * generate new sequences of pairs of hidden and control variables that follow the model.
    * @param seq sequences of pairs of "whether to omit observed variable" and control variable
    * @param initStateMean
    * @param initStateCovariance
    * @param seed for generating random(stochastic) variable
    * @return
    */
  def run(seq: Array[(Option[DenseVector[Double]], Boolean)], initStateMean: DenseVector[Double],
          initStateCovariance: Matrices, seed: Long = System.currentTimeMillis() + code): Array[(DenseVector[Double], Option[DenseVector[Double]])] = {

    //return the N-length array of random values generated by Gaussian distribution of mean 0, covariance matrix M
    def toGaussianArray(M: Matrices, N: Int): Array[DenseVector[Double]] = {
      M match {
        case DenseMatrices(matrix) =>
          val ms = eig(matrix)
          val O = ms.eigenvectors
          val L_h = diag(ms.eigenvalues.map(x => Math.sqrt(x))) //lambda^(1/2)
          val g = breeze.stats.distributions.Gaussian(0, 1)
          val pre = Array.fill(seq.length)(DenseVector.rand(M.cols, g))
          pre.map(x => O * L_h * x)
        case DiagMatrices(vector) =>
          val vectorGauss = vector.map(x => breeze.stats.distributions.Gaussian(0, Math.sqrt(x)))
          Array.fill(N)(vectorGauss.map(_.sample()))
      }
    }

    //generate array of stochastic variables
    val QGauss = toGaussianArray(Q, seq.length)
    val RGauss = toGaussianArray(R, seq.length)
    val initStateGauss = toGaussianArray(initStateCovariance, 1)(0)

    val result: Array[(DenseVector[Double], Option[DenseVector[Double]])] = Array.fill(seq.length)(DenseVector[Double](), None)
    seq.indices.foreach(i => {
      val x = if (i == 0) {
        initStateMean + initStateGauss
      } else {
        val prevx = result(i - 1)._1
        val bcs = seq(i - 1)._1 match {
          case Some(c) => B.get * c
          case None => DenseVector.zeros[Double](n)
        }
        A * prevx + bcs + QGauss(i)
      }
      val z = if (seq(i)._2) Some((H * x) + RGauss(i)) else None
      result(i) = (x, z)
    })
    result
  }

  //calculate difference between two Kalman Filter by summing up all the norm of each element of each parameter
  def calcDif(kf: KalmanFilter): Double = {
    val aNorm = (kf.A - this.A).norm
    val bNorm = kf.B match {
      case Some(b) => (b - this.B.get).norm
      case None => 0.0
    }
    val hNorm = (kf.H - this.H).norm
    val qNorm = (kf.Q - this.Q).norm
    val rNorm = (kf.R - this.R).norm
    Math.sqrt(aNorm * aNorm + bNorm * bNorm + hNorm * hNorm + qNorm * qNorm + rNorm * rNorm)
  }

  //calculate sum of two Kalman Filter by summing each element of each parameter
  def +(kf: KalmanFilter): KalmanFilter = {
    val newA = this.A + kf.A
    val newB = B match {
      case Some(b) => Some(b + kf.B.get)
      case None => None
    }
    val newH = this.H + kf.H
    val newQ = this.Q + kf.Q
    val newR = this.R + kf.R
    KalmanFilter(newA, newB, newH, newQ, newR)
  }

  /**
    * calculate maximum relative error of each parameter, of another Kalman Filter(@param kf) against this Kalman Filter.
    * for each parameter, relative error of each element is calculated and its maximum is taken.(see Matrices.maxDif and utils.Utils.maxDif for detail)
    * output is given by array of maximum relative error of each pamarameter.
    *
    * @param kf
    * @param fixDelta
    * @return
    */
  def maxDifs(kf: KalmanFilter, fixDelta: Double): Array[Double] = {
    val Adif = A.maxDif(kf.A, fixDelta)
    val Bdif = B match {
      case Some(b) => b.maxDif(kf.B.get, fixDelta);
      case None => -1.0
    }
    val Hdif = H.maxDif(kf.H, fixDelta)
    val Qdif = Q.maxDif(kf.Q, fixDelta)
    val Rdif = R.maxDif(kf.R, fixDelta)
    Array(Adif, Bdif, Hdif, Qdif, Rdif)
  }

  def max: Double = {
    Array(A.max, B.getOrElse(DenseMatrices(DenseMatrix.zeros[Double](1, 1))).max, H.max, Q.max, R.max).max
  }

}

object KalmanFilter {
  def zeros(n: Int, m: Int, l: Int): KalmanFilter = {
    val A = DenseMatrices(DenseMatrix.zeros[Double](n, n))
    val B = if (l == 0) None else Some(DenseMatrices(DenseMatrix.zeros[Double](n, l)))
    val H = DenseMatrices(DenseMatrix.zeros[Double](m, n))
    val Q = DiagMatrices(DenseVector.zeros[Double](n))
    val R = DiagMatrices(DenseVector.zeros[Double](m))
    KalmanFilter(A, B, H, Q, R)
  }

  def random(n: Int, m: Int, l: Int): KalmanFilter = {
    val generateGauss = GenerateCond(s = "gaussian,0.0 1.0")
    val generateGamma = GenerateCond(s = "gamma,2.0 2.0")
    val A = generateGauss.copy(seed = 0).makeMatrixForA(n)
    val B = generateGauss.copy(seed = 1).makeMatrixForB(n, l)
    val H = generateGauss.copy(seed = 2).makeMatrixForH(m, n)
    val Q = generateGamma.copy(seed = 3).makeMatrixForCov(n)
    val R = generateGamma.copy(seed = 4).makeMatrixForCov(m)
    KalmanFilter(A, B, H, Q, R)
  }

}